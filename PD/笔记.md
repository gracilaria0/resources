# C
## 1 绪论
程序设计 = 算法 + 数据结构 + 方法 + 工具  
### 程序设计的步骤
1. 问题的分析：问题的性质，输入输出形式，数据模型
2. 结构特性的设计：控制结构，数据结构
3. 算法的设计，原则：代价尽量小、结果可靠
4. 流程的描述：可用流程图（传统流程图和结构化流程图（NS图）），自然语言、算法描述语言、程序，任何流程都可以用顺序、选择（两路分支和多路分支）、循环（当型循环和直到型循环）三种基本结构结合而成
5. 调试与运行
   * 测试：通过一些典型例子，尽可能多地发现错误
   * 调试：找出程序中错误的位置并改正
### 程序设计语言
* 机器语言：二进制，底层，机器能且只能识别，移植性差
* 汇编语言：用指令助词符代替操作码，需要**汇编**成机器码
* 高级语言（程序设计语言）：
* 更接近自然语言  
  目标：可读性、易维护性、可移植性
  - 编译型
  - 解释型
  - 混合型
### C语言
$``$⏳

## 2 基本数据类型
### 记数制
* 十进制转换成$`X`$进制：
  - 整数：除以$`X`$取余
  - 小数：乘以$`X`$取整，不一定化
* $`X`$进制转换成十进制：
  各位以幂加权
### 计算机中数的表示
* 无符号数：$`X`$位表示范围$`\left[0,2^X-1\right]`$
* 原码：$`1`$位符号位（`0`正`1`负）+其他，$`X`$位范围$`\left[-2^{X-1}+1,2^{X-1}-1\right]`$
* 反码：正数的反码与原码相同，负数的反码是除符号位外各位取反
* 补码：正数的补码与原码相同，负数的补码是反码$`+1`$，$`X`$位范围$`\left[-2^{X-1},2^{X-1}-1\right]`$
* 偏移码：补码的符号位取反

* 定点数：纯小数，只保留小数部分
* 浮点数：$`1`$位符号+阶码$`N`$+尾数$`S`$
### 数据类型
#### 基本类型
* 整型：短$`2\mathrm{B}`$、长（普通）$`4\mathrm{B}`$、超长$`8\mathrm{B}`$
* 实型：IEEE 754双精度浮点数$`1`$位符号位+$`11`$位阶码+$`52`$位尾数共$`8\mathrm{B}`$，单精度$`4\mathrm{B}`$
  - 阶码：原值加偏移$`1023`$
    - 非规格化：全`1`表示无穷大，全`0`表示极小数
    - 规格化：非全`0`或全`1`
  - 尾数：
    - 非规格化：阶码全`0`时，$`S\times2\times2^{N-1023}`$
    - 规格化：$`1.S\times2^{N-1023}`$
* 字符型：$`1\mathrm{B}`$，GBK用两个`unsigned char`表示一个汉字
* 空型
* 复合类型：枚举、构造、指针等

## 3 输入输出
### 格式输出
`printf`格式输出函数，格式说明符`%[+][-][0]m.n[#]XY`
* `Y=``d`整型，`u`无符号整型，`o`八进制，`x`十六进制，`f`小数形式，`e`科学计数法形式，`g`表示自动判断用小数形式还是科学计数法形式，`c`字符，`s`字符串，`p`地址；大写表示用大写字母
* `X=``l`长型，`h`短型，`ll`超长型
* `m`表示输出宽度，包括小数点和小数部分，内容超出$`m`$时会输出原内容；`.n`表示小数点后的位数，默认是`.6`；`m`和`n`可以用`*`代替，在输出列表中的对应位置给定值
* `[-]`表示左对齐
* `[0]`表示在补齐输出宽度时用`0`而非` `
* `#`表示带上十六进制或八进制的格式符
* `+`表示正数也加上`+`
输出过程：先把待输出的内容输入的缓冲区，再按格式要求输出
返回值：输出的字符数
输出时改变值会导致未定义行为
### 格式输入
`scanf`格式输入函数，格式说明符`[*]%mXY`，其他为通配符
* `m`可以指定读取位数，把长数字自动分开
* 不能指定实型数据的位数
* `*`表示路过对应位置的输入
默认空白分隔符` `、`\t`、`\n`
输入时数据先放在缓冲区，接收到回车后清空缓冲区，放入输入流
返回值：正确输入的数据项的个数
### 字符输入输出
`putchar`和`getchar`正常
`conio.h`中
* `_getch`不等待回车，不在屏幕上显示
* `_getche`不等待回车，不在屏幕上显
* `_ungetch`把读入的字符放回输入流

## 4 表达式
表达式构成语句，执行顺序从右至左，语句用`;`结尾
### 算术运算
`+`、`-`、`*`、`/`、`%`
* 整型与整型相除，结果是整型
* 取余只能用于整型
返回值：算术运算结果
### 关系运算
`>`、`<`、`>=`、`<=`、`==`、`!=`
* ⚠️`-5 < x < 5`
返回值：`0`或`1`
### 逻辑运算和位运算
逻辑运算：`&&`、`||`、`!`，只能用于`0`和`1`间的运算；连续多个时，会短路操作
位运算：`&`、`|`、`^`、`~`，按数据的对应位进行运算
### 赋值
`=`把右侧赋给左侧，返回右侧的值
`X=`，`X`取算术符或位运算符，`a X= b`即`a = a X b`
### 其他
* 自增和自减`++`和`--`，只能用于左值，运算符在前时使用运算后的结果
* 大小运算算`sizeof`所占字节数⚠️`sizeof('\n')`结果是`4`，因为编译器认为`'\n'`是整数`10`
* 强制类型转换`<TYPE>()`
* 逗号`,`，从左到右计算，返回最右侧的值⚠️`int x, y;`中是分隔符

## 5 选择结构
### 简单语句和复合语句
简单语句：表达式语句、空语句、流程控制语句、返回语句
复合语句：用`{}`括起的语句，可以嵌套，局部优先
### `if`语句
```C
if(<表达式>) <语句1>
else <语句2>
```
语句2也可以是条件语句
### 条件运算符
### `switch`语句
```C
switch(<表达式>)
{
	case <常量表达式1>: case <常量表达式2>: <语句1>
	default: <语句2>
	case <常量表达式3>: <语句3>
}
```
表达式必须是整型或字符型
若无`default`且没有匹配则不做操作
⚠️加`break`

## 6 编译预处理
预处理命令不是语句，以`#`开头，没有`;`
### 定义
* 符号常量`#define P printf`
* 宏`#define C(x) (x)*(x)*(x)`
* 字符串化`#define P(x) printf("%s", #x)`：`P(12a)`→`printf("%s", "12a")`
* 字符串连接`#define P(x) printf("%d", a##x)`：`P(1)`→`printf("%d", a1)`
`#undef`
### 包含
`#include <文件名>`按系统标准方式检索  
`#include "文件名"`先从文件所在目录检索，再按标准方式  
作用：把文件内容全部复制到命令位置  
不能循环包含；不能包含`.c`文件，因为多次包含时会产生重定义问题  
使用标准函数（C库函数）时需要包含头文件，目的是函数的前向引用说明，否则会链接时报错
### 条件编译
`#ifdef`、`#ifndef`、`#else`、`#endif`、`#if`、`#elif`
作用：增强代码的可移植性
### 杂注
`#pragma <指示>`
作用：指示编译器如何进行编译
`#pragma once`只包含一次当前文件
`#pragma warning(disable:4996)`不显示4996类警告
`#pragma`
### 行号
`#line <自定义行号> ["自定义文件名"]`编译信息中，从此行起，显示\[自定义文件名]从自定义行号开始计算的行号

## 7 循环结构
### `while`语句
`while(<表达式>) <语句>`和`do <语句> while(<表达式>)`
### `for`语句
`for(<初始化表达式>;<条件表达式>;<改变表达式>) <语句>`
### 流程控制
* `break`跳出`switch`语句或循环结构
* `continue`结果本次循环的执行

## 8 模块设计
### 模块化设计
按功能划分模块的好处
* 可读性与可理解性
* 可修改性与可维护性
* 可验证性
* 可重组性和可重用性
### C函数
`<返回类型> 函数名(形式参数列表) {函数体}`
不指定返回类型时，为`int`  
不声明直接定义函数时，编译器假定返回`int`，若之后再定义返回非`int`的函数体，则会引发重定义错误  
函数不能嵌套定义  
### 参数传递
形参与实参结合的方式
* 地址结合：可以实现数据的双向传递，只能传递左值
* 数值结合：只传递值，实现单向传递
C语言用程序栈传递参数，从右向左压栈  
在C语言中，形参为简单变量时，采用数值结合
### 全局变量
在函数外部定义，其他文件中引用时加`extern`
* 局部优先，全局变量被掩蔽
* 降低模块的内聚性
* 始终占用空间
### 存储控制
* `auto`局部变量默认为自动类型
* `static`
  - 为局部变量声明则为局部静态变量，每次调用函数的值相同
  - 为全局变量声明则其他文件无法引用此全局变量，作用域变为文件
  - 为函数声明则只能被本文件函数调用
* `extern`
  - 引用其他文件中的全局变量
  - 或引用文件靠后位置才定义的静态变量
  - 函数默认为外部，可以被其他文件中的函数调用
* `register`提示此变量常用，**建议**编译器保存在寄存器中

| 程序区   | 静态存储区                   | 动态存储区            |
| ------- | --------------------------- | --------------------- |
| 存放程序 | 程序开始执行时分配（固定大小） | 函数调用过程中动态分配 |

作用域：复合语句⊂函数⊂文件⊂全局
### 递归调用
* 直接递归（自递归）
* 间接递归：通过其他过程调用自身
写递归的方法与数学归纳法相似  
Fortran不支持递归  
典型问题：Hanoi塔、上台阶、组合数、Fibonacci数列

## 9 数组
`<类型> <数组名>[<常量表达式>] = {<初始化列表>}`
`int a[] = {1, 2}`
`int a[3] = {1}`
`static int a[3]`
`int a[2][3] = {1, 2, 3, 4}`
`int a[2][3] = {{1, 2}, {3}}`
`int a[][3] = {1, 2, 3, 4}`
`int a[][3] = {{1, 2}, {3}}`
`char a[] = "hlwd"`
字符串由`'\0'`结尾
### 字符串函数
`puts`、`gets`
* `strcat(<str1>, <str2>)`把2连接在1后面并返回1的地址
* `strcpy(<str1>, <str2>)`把2复制到1中
* `strlen`不包括`'\0'`的长度
* `strcmp`字典序比较
* `strlwr`、`strupr`大小写转换
* `sprintf`、`sscanf`字符串输入输出
多维数组作形参时，非第一维的大小不能省略`foo(int arr[][2][3])`

## 10 指针
```C
int *p, i;
p = &i;
```
指针大小和编译器有关，32位是$`4\mathrm{B}`$，64位是$`8\mathrm{B}`$
`a[i]`=`*(a + i)`
* `int **p`整型二维指针
* `int *pa[10]`→`int* pa [10]`包含10个`int*`的数组
* `int (*lp)[10]`→`int (*lp) [10]`一行10个`int`的行指针
* `int *f()`→`int* f()`返回类型是`int*`的函数
* `int (*fp)()`→`int (*fp) ()`指向`int f()`这类函数的指针
* `int (*fpa[10])()`函数指针数组
调用函数指针时，可以`(*fp)()`，也可以`fp()`
### 自增自减运算
```C
<TYPE> *p;
p++;
```
`p`会增加`sizeof(<TYPE>)`，指向下一个元素（不保证有）  
`++`>`*`
* `*p++`→`*(p++)`→`*p; p++`，值是`*p`
* `(*p)++`→`(*p)++`，值是未自增前的`(*p)`
### 指针和字符串
```C
char a[] = "abc";
char b[] = "abc";
char *c = "abc", *d = "abc";
```
* `a == b`假，因为为不同的数组分配了不同的空间
* `c == d`真，因为编译器发现两者内容相同，把两者指向了同一片区域，区域中是常量字符串`"abc"`
* `strcmp`任意两者都是相等的

可以直接使用字符串`printf("%s", "How do you do!"+4)`=do you do!
不能修改没有自己内存的常量字符串
```C
char *s = "abc";
s[0] = 'A'; // 编译不报错，运行时出现段错误
```
也不能把标准输入的字符串直接给指针，因为标准输入的字符串系统不分配空间

数组名是指向数组首地址的指针常量（纯右值）
```C
int arr[2] = {1, 2}, brr[2];
brr = arr; // 表达式必须是可修改的左值
int a = 1, b = 2;
int *const pa = &a;
pa = &b; // 表达式必须是可修改的左值
```
这两种情况是等效的
### 常量指针
```C
int a = 1;
const int *p = &a;
*p = 2; // 表达式必须是可修改的左值
```
### 指针和二维数组
`int a[2][3] = {{1, 2, 3}, {4, 5, 6}}`
* `a`是第一行的地址，也即第一个元素的地址
* `*a`=`a[0]`是第一行第一个元素的地址，即第一个元素的地址，`a`=`*a`
* `**a`=`*(a[0])`=`a[0][0]`是第一个元素=1
* `*a + 1`是第一行第二个元素的地址，也即第二个元素的地址
* `a+1`是第二行的地址，也即第二行第一个元素的地址
* `*(a+1)`=`a[1]`是第二行第一个元素的地址，`a+1`=`*(a+1)`
* `*(a+1)+1`=`a[1]+1`是第二行第二个元素的地址
* `*(*(a+1)+1)`=`a[1][1]`是第二行第二个元素=5
### 内存分配
`p = (<指针类型>)malloc(sizeof(<TYPE>) * N)`指针类型是指针的定义中去掉指针名
申请失败返回`NULL`  
使用后需要`free(p)`，释放顺序最好和申请顺序相反
`calloc`申请后自动初始化为`0`
`realloc`重新申请，大于原有则新的部分不初始化，小于则可能造成数据丢失
### 主函数参数
`int main(int argc, char *argv[])`
命令行调用时传入参数个数，`argv[0]`=可执行文件路径

## 11 构造
### 结构体
```C
struct Student
{
  char name[20];
  int age, score;
  struct Date birthday;
  int (*get)(int);
} stu1, stus[20], *pstu;
```
* 可以不指定名称，定义无名结构体，直接定义在后面定义变量
* 可以直接在后面定义对象，即使不定义也要加`;`
* 可以嵌套定义
* 可以用`struct Student stu = {"Zhao", 1, 100, {2004, 1, 1}}`赋初值，内嵌的结构体可以不加`{}`，类似多维数组
* 成员运算符`.`；指向运算符`->`直接从指针获取`pstu->age`=`(*pstu).age`；两者优先级最高
* `#pragma pack()`按字节对齐，不够的补齐，默认是`4`；只能取2的幂，否则`warning C4086`
典型使用：链表
```C
struct Node
{
  int data1, data2;
  struct Node *next;
} *head = NULL;
```
### 联合体
`union`与结构体类似，但只能取其中一个成员，体积是最大成员的体积
* 可以和结构体嵌套
* 引用时引用成员，而非联合体名本身
### 枚举

```C
enum Week {SUN, MON, ERROR=-1} today;
today = SUN;
```
* 实际是从`0`开始的整数，可以强制类型转换`(enum Week)1`，但不能直接用整数赋值
* 可以显式指定值
### 自定义类型
`typedef struct Student Student, *PStudent`
### 复制
* 浅复制：直接`=`赋值
* 深复制：给指针新开辟内存，指向两块不同的内存，修改时不会同时修改

## 12 文件
文本文件和二进制文件
* 缓冲文件系统：高级文件系统，程序和缓冲区交流，速度更快，断电丢失
* 非缓冲文件系统：低级文件系统，直接读写硬件，开机时加载操作系统是非缓冲的
### 文件操作
`FILE`结构体，`stdio.h`中定义，用来标识打开的文件
文件打开方式`{r, w, a}[+]{t, b}`
* `fputc`、`fgetc`、`fputs`、`fgets`
* `feof`结束时返回非零
* `fread`、`fwrite`二进制读写
* `fscanf`、`fprintf`格式读写
* `rewind`移到开头，`fseek(FILE *fp, long offset, int origin`移动指针，`ftell`当前位置
* `fflush`清空缓冲区，立即输出到文件（读刚刚写入的内容时需要）
* `clearerr`清除错误状态
标准输入输出是`stdin``stdout`文件


# C++
## 1 基本问题
### 概念
* 数据抽象：数据类型与操作分开
* 对象：有封闭性，是类的实例
* **面向对象**：以对象的基础的思考方式，对应C的面向过程
  **面向对象的重要特征：封装、继承、多态**
* 泛型：程序尽可能通用，实现类型参数化，达到复用的目的
### 类型
`bool`类型，可取`true`或`false`，赋其他值会强制转换
### 注释
行注释`//`
### 输入输出
流输入输出`iostream`
头文件没有`.h`时，需要加使用标准命名空间
* `setw(int)`设置后一个内容宽度，自动突破；`setprecision(int)`设置后一个小数位数；两者需包含`iomanip`
* `hex`、`oct`、`dec`设置随后所有整数进制
* `endl`回车
* `cin.getline`读取结束符，`cin.get`不读取结束符，都不保存结束符
### 内联函数
`inline`把函数内容嵌入调用位置，活动调用的栈操作和跳转操作  
不能出现递归等无法内联化的情形，否则忽略关键字
### 动态内存分配
`new`和`delete`  
`int *p = new int[10]`  
无论一维还是多维，只需`delete []p`
### 引用
引用可以看作给变量起的别名`int &r = i`，则`r`和`i`占据同一个地址空间  
通过引用可以实现参数的地址结合`void swap(int &a, int &b)`→`swap(x, y)`  
不能返回局部变量的引用，类似不能返回局部变量的指针  
引用变量定义引用后不能再把变量定义为其他的引用
### `const`
`int const a`=`const int a`  
`int *const p`→`p`不能被修改；`const int *p`→`p`指向`const int`，`*p`不能被修改
### 作用域
`::`作用域操作符，`v`引用局部变量，`::v`引用全局变量  
#### 命名空间
`namespace <空间名> {<内容>}`可以包含变量（可以初始化）、常量、函数（定义或声明）、结构和类、模板、命名空间  
可以起别名`namespace N2 = N1`  
可以用`using`指定默认空间`using namespace N1`，也可以只使用其中一部分`using N1::v1`  
作用域：复合语句⊂函数⊂文件⊂类⊂命名空间⊂全局
### 缺省参数
`<TYPE func(int i=1)`

## 2 函数重载（overload）
要求：函数名相同，形参列表不能完全相同  
确定方式：**静态束定**，实参列表是决定性因素
> 补充：
> 束定（binding），联编，绑定，指确定函数调用与被调函数之间的映射关系
> * 静态束定：编译时确定，有一定的缺陷
> * 动态束定：运行时确定，动态束定在C++中由虚函数支持

## 3 类
`class`类是对象的抽象，对象是类的实例；类不占据内存，是一个模板  
`class MyClass {<成员>};`成员可以包含其他类  
可以继承和派生`class`  
可以嵌套定义  
有的编译器要求，若需要引用之后才定义的类，需要先声明`class Latter;`  
访问控制——
* 公有`public`所有人可访问
* 私有`private`仅本类可访问
* 保护`protected`本类及派生类可访问
### 构造函数和析构函数
构造函数与类同名，析构函数前面加`~`
* 若不显式显式定义，编译器会自动生成默认的
* 须在公有部分声明，构造函数须一一声明各个重载
* 没有返回类型  
声明`inline`或把函数定义写在类内时，编译器会把符合要求的构造函数实现成内联函数
### 复制构造函数
形参只有一个——本类对象的（常）引用`MyClass(const Myclass &)`  
不定义时也会生成默认的复制构造函数，但是浅复制  
调用情形——
* 用一个对象去初始化新定义的对象
* 形参是对象，调用时进行数值结合
* 返回值是对象，返回后把它复制给调用者
> 补充：
> 移动构造函数`MyClass(const Myclass &&)`（C++11后也会默认生成）
> 接收一个右值（可移动的值），把内容直接移动（如浅复制）给调用者，省去了复制的浪费
### 常成员函数和常对象
函数不会对类成员做出任何修改，常对象只能调用常函数  
可以定义仅有`const`区别的两个重载函数，常规情况下只调用普通版本，常对象调用常版本（也可以定义参数仅有`const`区别的重载函数，普通对象可以匹配`const`形参，但常对象不能匹配普通形参）  
成员声明`mutable`后，常函数也可以修改
### 静态成员
静态成员在对象间共享；若函数只访问静态成员，则可声明成静态成员函数  
赋初值需要在主函数外，可以在类的定义文件（`.cpp`）中执行`int MyClass::count = 0`；只有常静态成员可以在类内直接赋初值`static const int count = 0`  
静态成员函数不能声明`const`
### 友元
白名单制，`friend`声明非本类成员函数的其他函数，也可以访问私有成员  
类内声明后，定义时不需要加`friend`和`MyClass::`  
可以把其他类声明成本类的友元`friend class Else`，则其所有成员函数都可以访问本类的私有成员
### 自引用
`this`是指向本对象的指针，只能在成员函数中使用  
`this`的类型是`MyClass *const`，无法修改指向新的内容；但其成员可以修改`this->data = `...

## 4 运算符重载
只能重载已有的运算符，不能重载`.`、`.*`、`::`、`?:`、`sizeof`、`typeid`6个运算符，运算符的优先级不改变  
实际上是转化成对运算符函数的调用  
成员式`a+b`→`a.operator+(b)`，友元式`a+b`→`operator(a, b)`  
自增运算符
|           | 成员式（推荐）    | 友元式             |
| --------- | ----------------- | ------------------ |
| 后置`a++` | `a.operator++()`  | `operator++(a)`    |
| 前置`++a` | `a.operator++(0)` | `operator++(a, 0)` |
### 赋值运算符
* 注意深复制
* 返回自身引用`return *this`
### 位移运算符→流操作
必须重载为友元函数；否则需要重载为`istream`和`ostream`类的成员函数，需要修改系统类的定义  
形式`friend istream &operator>>(istream &, MyClass &)`
### 类型转换运算符
`operator double()`⚠️前面没有返回类型  
定义自定义类如何转换为其他类型  
要慎用，因为强制类型转换的优先级很高：复数类
```C++
class Comp
{
public:
  Comp(double r, double i=0.): real(r), imag(i) {}
  operator double() {return real;}
private:
  double real, imag;
};

void test() {Comp c = Comp(1, 1) + 1.5;} // 结果是Comp(2.5, 0)
```

## 5 继承和派生
继承：构造新类的过程中保持已有类的特性
派生：已有类的基础上新增自己的特性
`class <派生类>: <访问控制> <基类> {};`  
可以声明同名变量，调用时默认是派生类的，除非加`Parent::data`
### 访问控制
* 公有继承：权限保持不变
* 私有继承：全部变成私有
* 保护继承：公有变成保护，其他不变  
对派生类来说，除了三种权限的成员，还有基类的私有成员这类无法访问的成员  
可以把派生类声明成基类的友元类，则派生类可以访问基类的私有成员❔  
可以有成员的类与基类相同  
可以调整访问权限，但不能超过原有权限
```C++
class Filialis: private Parent // 全部变成私有
{
public:
  Parent::data; // 把data重新设为公有（保护也可以）
}
```
### 构造函数
普通构造`Filialis::Filialis(<参数表>): Parent(<参数>) {}`  
复制构造`Filialis::Filialis(const Filialis &f): Parent(f) {}`会自动拿出基类的部分去复制构造基类
### 虚函数
声明`virtual`的成员函数是虚函数，虚函数实行动态束定  
动态束定由`this`指针在运行时通过虚函数表（vtable，虚表）决定启用哪个成员函数  
> *实现原理：*
> 包含虚函数的类自动带有一个静态的（常的）虚函数表和一个（非静态）虚函数指针（vptr）
> 虚函数表实际上是一个函数指针数组，储存了指向本类中所有虚函数的指针，而虚函数指针指向虚函数表
> 在派生时，编译器保证所有虚函数在表中的位置是对应的。在派生类中，若重写了函数，则指向本类重写的函数；若未重写，则指向基类中对应的函数
> 调用时，先根据对象中的虚函数指针找到虚函数表，再通过相对位置找到所调用函数在表中的索引，进行调用
包含虚函数的类是**多态类**，多态性（polymorphism）是面向对象的重要特征
* 静态束定：编译时给出函数地址
* 动态束定：编译时只给出函数在虚函数表中的相对位置
要求：参数表完全相同，修饰词相同，返回值相同或为协变返回类型
> *协变返回类型：*
> 派生类中重写基类虚函数时，返回类型可以是基类虚函数返回类型的派生类类型
> 这只适用于**指针**或**引用**类型
满足要求时，不加`virtual`编译器可能也会实现为虚函数（建议写保证可读性）  
派生类也可以不重写；重写时可以加上`override`，帮助编译器确认我们要进行重写。而非定义新的函数
#### `final`
* 禁止继承`class Filialis final`
* 禁止重写`void vfunc() override final`，派生类无法再重写这个函数，此后使用静态束定
#### 兼容性
* 派生类对象可以当作基类对象使用，包括赋值和初始化
* 基类指针和引用可以指向派生类对象
#### 纯虚函数
`virtual <TYPE> pvfunc()=0;`无函数体，包含纯虚函数的类是抽象类，无法实例化（但可以定义指针，后续用于指向非抽象的派生类）
#### 虚析构函数
不定义时，会静态束定：用基类指针指向派生类对象时，析构对象只调用基类的析构函数   
`virtual ~Parent()`使一系列派生类的析构函数变为同族虚析构函数，虚析构函数是唯一函数名不同的虚函数族
### 多继承
```C++
class Filialis: public P1, protected P2, ...
{
  Filialis(<args>): P1(...), P2(...) {} // 即使此处调换顺序，也按照继承顺序调用构造函数
};
```
#### 二义性（ambiguous）
* 多个基类都有同名成员，此时需要加类名限定`P1::data`  
* 若派生类也定义了同名成员，则会发生掩蔽
* 不止一个基类派生自相同的基类
  ```C++
  class P {public: int a;};
  class F1a: public P {};
  class F1b: public P {};
  class F2: public F1a, public F1b {} f2;
  ```
  这种情况`F2`中会有两份`P`，成员用类名限定访问`f2.F1a::a`
#### 虚基类
同上面情况，若子一代声明`P`为虚基类
```C++
class P {P(...) {}};
class F1a: virtual public P {F1a(...): P(...) {}};
class F1b: virtual public P {F1b(...): P(...) {}};
class F2: public F1a, public F1b {F2(...): P(...), F1a(...), F1(...){}};
```
则`F2`中只有一份`P`  
此时，不可能再让子一代的两个类分别调用`P`的构造函数，需要`F2`跨代调用  
⚠️子一代中还是需要写清如何调用`P`的构造函数，只是通过虚基类机制，`F2`没有调用

## 6 模板
模板是用于支持参数化多态性工具，通过类型参数化，实现代码复用  
`template <<参数表>> <（或定义）>`参数表用`class`或`typename`关键字指定不定类型
### 函数模板
`template <typename T> T func(T a, T b) {return a<b?a:b;}`  
编译过程中，调用时尝试根据参数类型生成一个函数  
若有同名的重载函数，则先匹配重载函数，再尝试生成
### 类模板
```C++
template <typename T>
class Stack
{
public:
  Stack(int size);
  Stack(const Stack <T> &);
  virtual ~Stack();
  void push(const T &);
  const T &pop();
  ...
private:
  T *buff;
  ...
};
```
### 模板参数
本来的情况中，由于需要根据传入的实参得知类型，所以模板参数必须出现在形参表中
`template <typename A, typename B> B func(A a, B b) {...}`
向模板传入实参可以告知不可推断的类型
```C++
template <typename A, typename B, typename R>
R func(A a, B b) {...}

void test() {func<double, int, long>(1, 2L);}
```
也可以把实现中的常量参数化
`template <typename T, int Rows, int Cols> T * mySumCol(const T arr[][Cols]) {...}`
### 静态变量
模板中声明的静态对象并不是一个模板只对应一个（跨类、跨函数），而是编译时生成的每种类或函数只对应一个（跨对象、跨调用）  
若编译时根据调用生成了`T`=`double`和`T`=`int`两种类或函数，则这两者中的静态变量是不同的

## 7 流输入输出
流（stream）是一种抽象，负责在两个对象间建立联系，并管理数据的流动

## 8 异常
目的：提高容错（fault-tolerance）鲁棒性（robustness），避免出现致命错误、死机等情况  
`throw`抛出，`try`执行，`catch`捕获处理
```C++
double myDiv(int a, int b) {if(!b) throw 0; return (double)a/b;}
void test()
{
  try
  {
    double c = myDiv(1, 0);
  }
  catch(int errCode)
  {
    switch(errCode) {...}
  }
  catch(double errMsg) {...}
}
```
可以用`new(std::nothrow)`阻止申请内存时直接抛出错误中止运行
### 断言
`assert`是一个宏（来自C），用于验证自己做出的假设为真  
`assert(<条件>)`在条件为假时，打印诊断信息并中止程序

## 9 标准模板库（STL）
泛型程序设计：把程序写得尽可能通用，便于复用  
模板是泛型的基础，STL是泛型程序设计的范例  
不同编译器的实现不同，但接口是国际标准化的
STL的基本组件是：容器、迭代器、函数对象、算法
### 容器
向量、双端队列、列表、集合、多重集合、映射、多重映射7种  
前三种是顺序容器，集合和映射是关联窗口  
通用方法——
* 普通方法`swap`、`clear`、`empty`、`size`、比较大小的6个运算符（按元素字典序比较）
* 迭代方法`begin`、`end`、`rbegin`、`rend`
### 适配器
适配为已有的类提供新的接口，简化、约束、安全化原有类  
容器、迭代器、函数对象都有适配器  
容器适配器如栈和队列
### 迭代器
包含头文件`iterator`
* 输入输出迭代器，可以从流中连续地输入输出
  ```C++
  transform(
    istream_iterator<double>(cin),
    istream_iterator<double>(),
    ostream_iterator<int>(cout, " "), square)
  ```
  读入若干个数，平方后输出
* 前向迭代器
* 双向迭代器
* 随机访问迭代器
### 算法
包含头文件`algorithm`  
提供了70多种算法，如排序、部分排序、稳定排序等
### 函数对象
包含头文件`functional`  
行为类似函数的对象，普通函数和重载了`()`运算符的类都是函数对象  
STL中定义了一些标准函数对象，分为算术、关系、逻辑三种运算